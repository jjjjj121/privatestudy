#include <iostream>

//메모리 영역
//힙 영역(동적할당)
//프로그램을 실행 이후(도중)에 실시간으로 대응할 수 있도록 만들어진 메모리 영역.
//ex>프로그램 실행 이후 엔터를 누르면 int 변수가 하나 나오도록, 엔터를 누르지 않으면 변수가 생성되지 않도록 -> 프로그램 실행 이후 실시간으로 코드가 적용되는 현상


int main()
{
	malloc;    //메모리 할당 함수
	malloc(100); //이 코드가 수행되는 순간에 100byte를 힙 영역에 만듬.

	int* pInt = (int*)malloc(100);      //힙영역(100 byte)의 시작 주소값을 int 포인터 변수 pInt에 넘겨줌.
	                                    //pInt는 main 스택메모리 안에 있는 포인터 변수로 malloc으로 생성된 힙 영역의 시작 주소값에 접근.
	                                    //(int*)로 malloc을 강제 캐스팅한 이유 : malloc은 반환타입이 void * 타입인데 그 이유는 malloc은 힙영역에 메모리 영역만 할당하고 주소를 줄 뿐, 그 영역을
	                                    //어떤 자료형으로 사용할지는 사용자가 결정할 문제이기 때문에, 자료형 타입을 구분짓지 않는 void 포인터 타입으로 되있음.



	float* pF = (float*)malloc(4);      //힙영역에 4byte 메모리 영역을 생성-> 이 주소값을 float 자료형으로 보겠다.
	int* pI = (int*)pF;                 //int포인터로 강제 캐스팅해서 보겠다. =pI 와 pF가 가리키는 주소값은 힙영역에 생성된 4byte 영역으로 둘 다 같은것을 가리키고 있음.

	*pF = 2.4f;                         //pF 주소값에 실수형 데이터 2.4를 대입
	int i = *pI;                        //이를 pI Int형 자료형으로 해석 -> 데이터는 실수인데 해석은 정수로하니 결과값은 이상한 값이 나오게됨.


	//동적할당 (특징)
	//1. 런타임 중에 대응 가능.
	//2. 사용자가 직접 메모리를 관리해야함(해제) -> 다른 메모리 영역은 컴파일러가 알아서 해제를 시켜주지만 힙 메모리 영역은 사용자가 직접 해제를 해줘야함.

	int iInput = 0;

	int* pInt = nullptr;
	scanf_s("%d", &iInput);

	if (100 == iInput)                   //scanf에서 100을 입력하면 힙메모리에 100바이트 할당. 100이 아닌 수 입력 시 할당 x.
	{                                    //여기서 문제는 100을 입력했을 때 호출이 될지 안될지는 프로그램 실행이 되야 알기 때문에 프로그램 자체에서 메모리 해제를 해주지 않음.
		pInt = (int*)malloc(100);        //따라서 사용자가 메모리 영역을 직접 해제해줘야함.

	}

	if (nullptr != pInt)     //프로그램  끝나기 전에 이 함수를 적용 시켜 힙메모리 영역을 해제해줘야함.
	{
		free(pInt);           //free는 내가 주소를 전달해 주면, 그 주소가 가리키는 곳(힙 메모리 영역)을 해제 시켜주는 함수. 

	}



	//가변 배열

	int i = 100;
	int iArr[i] = { };    //지역변수 i는 변수로 변하는 값으로 이렇게 되면 int배열의 크기가 변한다는 뜻인데, 그러면 컴파일단계에서 이 메인함수의 스택메모리를 얼마정도 할당해야하는지
	                      //예측을 할 수 없기 때문에 스택 메모리 값을 할당해줄 수 없게 되므로 변수가 아닌 상수로 적어줘야 한다.
	                      //따라서 배열의 크기가 변하는 가변배열을 만들기 위해서는 런타임중 대응이 가능한 동적할당(힙) 메모리 영역에서 관여를 해야한다.
	
	//배열 개수를 선언할 때에는 변수를 사용 할 수 없다.

	//객체(Instance)
	//ex ) int a; <- int자료형을 실체화 한 a를 객체라고 한다. 비유하자면 도장이 자료형이라면 도장으로 찍어낸 물체(결과물)이 객체

	//따라서 가변 배열의 기능을 하는 자료형을 만들어서 이 자료형을 하나 생성시키면, 가변배열을 하는 객체 하나가 생성되도록 할 것.



	return 0;
}


#include <iostream>
#include "Arr.h"


int main()
{
	tArr s;
	s.pInt = (int*)malloc(40);
	s.iCount = 0;
	s.iMaxcount = 10;  //malloc으로 40byte를 생성했으니, 자료형은 int포인터 이기 떄문에 4byte당 1번 카운트 되기 때문에 최대치는 총 10이다.
	//위 자료들은 매번 할 때마다 확인하고 신경써서 하기엔 번거로우므로, 이것을 함수로 만들어서 사용할때마다 편하게 사용할 수 있도록 만들 것.

	return 0;
}



int main()
{
	tArr s = {};  //tArr 가변배열 자료형을 사용하는 객체 s 를 선언.
	InitArr(&s);  // 함수에 s(가변 배열 객체)주소를 넘겨줌

	//여기서 객체 s 는 main함수가 종료될 때 해제가 된다. 그러나 객체s 가 실질적으로 데이터를 남긴 공간(주소값) 즉, 힙메모리 영역에 남겨진 데이터는 사용자가 해제를 해야함.
	//따라서 main함수가 종료되기 직전에 객체 s에게 힙메모리 공간 해제하라고 지정해줘야함.

	for (int i = 0; i < 10; ++i)
	{
		PushBack(&s, i);             //s배열에 0~9까지 데이터를 집어넣음.
	}

	//제대로 값이 들어갔는지 확인
	for (int i = 0; i < s.iCount; ++i)
	{
		printf("&d\n", s.pInt[i]);       //각 배열에 0~9까지 들어갔는지 확인하기 위해 객체 s의 각 배열을 출력하도록 함.

	}

	ReleaseArr(&s);  //메모리 해제

	return 0;

}



#include <time.h>
	//난수(랜덤) ->rand함수를 사용하기 우해서 time.h 참조 필요
	//프로그램에서 난수는 무작위로 설정된 난수 페이지를 참조하는 방식. 
rand();                     //결국 완벽한 랜덤은 아니다. 왜냐하면 난수 페이지에 무작위로 적혀진 데이터가 결국은 순서대로 나오기 때문에 반복실행하다보면 비슷한 패턴이 나오게된다.
srand(time(nullptr));       //srand 함수는 시드값을 통해서 페이지를 변경시켜주는 함수로 굉장히 많은 난수 페이지가 준비되어 있고, 그 페이지중 임의의 페이지를 골라서 그 페이지에서 데이터를 가져오게된다.
							//그러나 시드값도 똑같이 주게되면 결국 동일 페이지의 동일 데이터가 똑같이 나오게 되므로, 시드값도 다르게 줘야 제대로 보완이 된다.
							//그래서 시드값에 현재 시간값을 넣어주는 것(시간은 계속 흐르기 때문에 같을 수가 없음.)
							// 
	//0~100사이의 랜덤한 숫자를 뽑고 싶을때 -> 난수 페이지 안에는 십단위, 백단위, 천단위 등 숫자가 다양하다.
	//난수 페이지안에 있는 모든 숫자를 100으로 나눈 나머지 값은 모두 0~99인 숫자가 된다.
	//ex) 50~100사이의 수를 뽑고 싶다. -> 모두 50으로 나눈 나머지값 : 0~50 -> 에 모두 50을 더한다 : 50~100


//버블 정렬 구현

int main()
{

	tArr s1 = {};



	for (int i = 0; i < 10; ++i)
	{
		int iRand = rand() % 100 + 1;

		PushBack(&s1, iRand);
	}

	for (int i = 0; i < s1.iCount; ++i)
	{
		printf("%d\n", s1.pInt[i]);
	}

	Sort(&s1);  //버블정렬

	for (int i = 0; i < 10; ++i)
	{
		int iRand = rand() % 100 + 1;

		PushBack(&s1, iRand);
	}




	return 0;
}

//함수 포인터
//함수안에 다양한 기능을 하는 여러개의 함수가 존재할텐데, 내가 원하는 기능을 하는 함수 한개만을 호출하고 싶을때, 함수 포인터를 사용하여 원하는 기능을 하는 함수 자체를 인자로 사용한다.

//Sort(정렬) 함수 안에서 여러 기능중 버블정렬의 기능을 하는 Bubblesort 함수를 main파일에서 구현.
void Bubblesort(int* _pData, int _iCount)  //필요인자 : int데이터로 한다고 쳤을 때, 1. 정렬할 데이터의 주소값 , 2.그곳에 들어있는 데이터의 갯수 
{
	if (_iCount <= 1)
	{
		return;
	}

	int a = 0;

	while (true)     
	{
		bool bFinish = true;

		for (int c = 0; c < _iCount - 1; ++c) 
		{

			if (_pData[c] > _pData[c + 1])
			{
				a = _pData[c];
				_pData[c] = _pData[c + 1];
				_pData[c + 1] = a;

				bFinish = false;
			}

		}

		if (bFinish)   
			break;      

	}
	//이제 이 버블소트 함수는 가변배열 뿐만 아니라 다른 일반 배열에서도 사용할 수 있다.
}

void Test()
{

}


int main()
{

	tArr s1 = {};

	Sort(&s1, Bubblesort);   //s1을 Sort함수에 있는 수많은 정렬 기능중에 Bubblesort기능을 사용하여 정렬해 달라! --> 함수포인터 사용하는 이유
	                         //함수는 이름자체가 주소로 판단하기 때문에, &Bubblesort , Bubblesort 둘 다 가능.


	//함수의 주소를 받는 법 (함수 포인터 선언 방법)
	void(*pFunc)(void) = nullptr;     //반환타입이 void이고 인자도 없는(void) 그런 함수의 주소(*pFunc)를 받는 함수포인터변수 'pFunc'
	
	pFunc = Test;                     //따라서 Test함수를 받을 수 있음.
	pFunc();                          //pFunc 을 호출하겠다는건 Test 함수를 호출하겠다는 뜻 



}

//연결형 리스트
//가변 배열은 결과적으로 생성된 인덱스가 연속적으로 이루어져 있기 때문에 배열의 형태를 이루고 있어서 가변 배열이라고 불린다.
//연결형 리스트는, 매번 동적할당을 통해 새로운 메모리 공간을 할당 해주면 불규칙한 위치(메모리 공간)에 데이터값이 저장되는데, 1번째로 할당된 데이터안에 다음 데이터 주소값이 저장되있고, 
//그 다음 데이터에는 또 그 다음 데이터 주소값이 저장된다. 따라서 시작 주소만 알면, 그 이후에 나오는 데이터값을 찾아갈 수 있음. 
//이 때, 데이터 하나를 저장하는 단위를 노드(마디)라고 부른다. 이 노드 하나에는 데이터값과 다음 노드를 가리키는 주소값도 들어있다.
// ㅁ(List)->ㅁ(1노드) -> ㅁ(2노드) -> ㅁ(3노드) -> ㅁ(4노드) 와 같이 노드가 연결되어 있음

#include "LinkedList.h"

int main()
{
	tLinkedList list = {};    //객체 선언(연결형 리스트)

	InitList(&list);         //객체 초기화


	PushBack(&list, 100);
	PushBack(&list, 200);
	PushBack(&list, 300);
	PushBack(&list, 400);




	return 0;

}

//데이터 생성에 방식에 따른 함수
//연결형 리스트 PushBack 함수 : 데이터 뒤쪽으로 생성됨.
//연결형 리스트 PushFront 함수 : 데이터 앞쪽으로 생성됨.



//----------------------------------------------------------------------------까지가 C언어 식 코드짜기










//정렬종류
//삽입 정렬
//선택 정렬
//합병 정렬(머지)
//쾌속 정렬(퀵)
//힙 정렬(힙메모리의 힙이 아닌 힙이라는 자료구조: 최소, 최대를 빠르게 찾아내는 자료구조)
//완전 이진트리(힙 자료구조를 하려면 완전 이진트리라는 배열을 먼저 구현해야한다.)






