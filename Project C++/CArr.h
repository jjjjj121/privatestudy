#pragma once

class CArr
{
	//가변 배열 자료형 파트(멤버 선언)
private:  //기본 접근 제한 지정자는 private로 지정 되어 있으므로 private를 안적어도 무방.

	int*	m_pData;
	int		m_iCount;
	int		m_iMaxCount;


	//데이터 생성 파트, 메모리 재생성파트
public:
	void push_back(int _Data);        //필요인자 : 들어갈 데이터
	void resize(int _iResizeCount);     //필요인자 : 늘릴 공간의 갯수

	
	//이 클레스가 일반적인 배열의 역할을 수행 할 수 있도록
	int& operator[] (int idx); //[]가 나오면 해당 인덱스가 호출되도록.
	                           //레퍼런스를 사용한 이유 : 기존 배열의 문법과 똑같이 실행 되도록 만들기 위해서.
	                           //사용된 레퍼런스의 의미는 반환되는 곳을 그대로(참조를) 전달하는것.(반환된 타입이 곧 인덱스와 동일 시 한다.)


	//잘못된 경우 2가지
	//int operator[] (int idx);    이 경우 자료형이 int이므로 인덱스의 주소를 받은것이 아니므로 해당 인덱스의 데이터는 확인 할 수 있지만, 데이터를 수정할 순 없다.
	//int* operator[] (int idx);   이 경우 자료형이 int*이므로 인덱스의 주소에 접근하여 수정도 할 수 있고 데이터 확인도 할 수 있지만 이것을 하기 위해선 기존 문법과 다른 포인터방식으로 접근을 해야하는
								// 번거로움이 생기므로 우리가 의도한 것은 기존 배열의 문법으로 편하게 접근하기 위함이다.






	//초기화 파트 , 메모리 해제 파트
public:    //생성자와 소멸자는 private 필드에 구현했으면 이 객체가 생성될때 생성자와 소멸자를 서치하지 못해서 오류가 발생함.
	CArr();
	~CArr();
};

