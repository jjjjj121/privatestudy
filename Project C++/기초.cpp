

// 주석  
//주석은 코드로 인식하지 않고, 부가적인 설명이 필요할 때 사용한다.

int main()
{

	//int : 자료형(크기 단위, byte) Data Type
	//i : 변수명의
	//자료형에는 정수형, 실수형이 있다.
	//정수형 : char(1), short(2), int(4), long(4), long long(8)  정수란 1,2,와 같이 딱 떨어지는 수
	//실수형 : float(4), double(8) 실수란 1.12xxx와 같이 소수점으로 나타내는 수
	//한마디로 int i는 i라는 내가 임의로 정한 변수를 int라는 자료형에 의해 수식이 되는 것.

	//근데 왜 정수형에 종류가 여러개인가? 정수의 크기가 달라지기 때문
	//그렇다면 아래 함수를 해석하자면 i라는 변수는 int이기 때문에 변수의 크기는 4byte이고(ㅁㅁㅁㅁ) 이안에 들어갈 숫자는 정수형 데이터가 저장될 것이고 이 변수의 이름을 i라고 한다.
	//byte 의 개념 1byte = 8bit(ㅁㅁㅁㅁㅁㅁㅁㅁ)<- ㅁ한개가 1bit로 최소단위이고 이는 있다 없다(0또는 1)와 같은 2가지 상태값만을 나타낸다.
	//그렇다면 int는 4byte 이므로 32비트이다.
	//1byte가 총 2의 10승 =1024 묶음이 모이면 1024byte라고 부르지 않고 1KB(1킬로바이트)라고 부른다.
	//1KB가 1024개가 모이면 1MB(메가바이트)라고 부른다. >> 1024MB= 1GB >> 1024GB= 1TB

	//1byte로 무엇을 할 수 있는가? >> 1byte=8bit 1bit당 상태값을 표현할수 있는 가짓수가 2가지 이므로 8bit는 2의8승인 256가지의 상태값을 표현할 수 있다.
	//추가로 이를 숫자(양수인 정수)로 표현하게 된다면 8bit는 0~255까지의 정수로 표현할 수 있다.


	int i = 0;


	//unsignde = 양의 정수를 뜻함. 따라서 unsigned char 는 양의 정수만을 나타내는 1바이트 크기의 자료형을 나타낸다.
	//또한 변수의 선언 즉 unsigned char c = 0;를 먼저 선언 해야 뒤에 나오는 c = 0;는 변수c에 0을 넣겠다 c = 255; 변수에 255를 넣겠다라는 대입 연산자를 뒤에 넣어야 문법이 맞게 떨어진다.
	//한마디로 순서도 생각해야함.
	//C++에서 =는 좌변과 우변이 같다라는 뜻이아닌 변수에 대입을 하라는 대입 연산자이다. 평소에 생각하던 부등호의 개념은 ==으로 이것은 양쪽이 동일한 개념이라는 뜻.

    //만약 c = 256; 을 대입한다면? 1/00000000 과 같이 8자리를 넘어가 버리기 때문에 0으로 표기가 된다.

	// 1바이트로 양수만 표현
	// 256가지 -> 0 ~ 255
	unsigned char c = 0;

	c = 0;
	c = 255;
	c = 256;

	// 1바이트로 양수, 음수 둘다 표현
	//256가지 -> -128 ~ 0 ~ 127

	char c1 = 0;
	c1 = -1;
	c1 = 255;

	//그렇다면 음수(-1)를 대입한다면?
	// 여기서 char c1 = 0;는 signed char c1 =0;와 같고 signed(음수와 양수 모두 나타냄)이 생략된것이다.
	//여기서 1byte는 256가짓수만 가진다 했는데, 음수와 양수까지 표현하려면 양수만 나타냈을때 보다 반으로 줄 수 밖에 없음. ex>-128~128
	//따라서 0/ㅁㅁㅁㅁㅁㅁㅁ 일때는 양수(128가지) 1/ㅁㅁㅁㅁㅁㅁㅁ일때는 음수(128가지)로 나타냄.
	//음수와 양수를 나타내는 맨 왼쪽에 있는 비트를 MSB라고 부른다(Most Significant Bit/가장 중요한 비트)
	//컴퓨터에서 음수는 10+()=0 과 같이 표현되는 수를 음수라한다. 한마디로 10과 더해서 0이 되는 수를 -10으로 보고 5와 더해서 0이되는 수를 -5라고 한다.
	//따라서 뺄셈이 아니라 덧셈으로 생각해야하고, 단순히 7비트가 똑같고 MSB만 0과 1로 다르면 같은 숫자의 양수와 음수인 것이 아닌것이다.
	//ex> 0111 1111 = 127이고 이고 이와 더해서 0이 되려면 1000 0001로써 8비트를 초과하여 결국 0과 같다. 따라서 1000 0001이 -127인 것이다.
	//ex> 0000 0001 = 1 / 1111 1111 = -1 이므로 c1 = 255; 는 -1 과 같다.


	//양수에 대응하는 음수를 빨리 찾는법 >> 2의 보수법 >> 양수의 비트를 모두 반전 시키고 +1을 한다.

	int a = 4 + (int)4.0;
	//정수와 실수는 표현하는 방식이 다르다. ex> 정수 4의 비트상태값과 실수 4.0의 상태값은 다르다.
	//실수는 부동소수점이라는 표현방식을 따른다.
	//부동소수점 -> 나무위키 참조
	//실수 표현 방식은 정밀도에 의존하므로, double(8) 자료형이 float(4)보다 더 아래의 소수점까지 정확하게 표현이 가능하다.
	
	//정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현방식의 피 연산자가 연산될 경우(실수와 정수가 혼재할경우) 명시적으로 변환하자.
	

	float f = 10.2415f + (float)20;
	//예를들어 위와같은 상황은 실수와 정수를 더하는 수식에서 실수표현방식으로 나타내고자 하는 함수이다.
	//정수앞에 (float)는 없어도 컴파일러가 실수표현방식으로 변형 후 계산을 할것이나, 위에 말한것처럼 명시적으로 명확하게 변환하기 위해(float)을 표기한다.
	


	// 연산자 
	//;-> 문장의 마감을 뜻한다. 마침표의 역할
	// 
	// 대입 연산자
	//= -> 대입한다.

	//산술연산자 ->사칙연산
	//+, -, *, /, %(모듈러스 연산자, 나머지 연산자)
	//++,-- (증감 연산자)


	int data = 10 + 10;
	//연산자에도 우선순위가 존재. 대입연산자<산술연산자
	//따라서 위 함수는 int data = 20;와 같다

	data = data + 20;
	data += 20;
	//위와 같이 추가적인 조건이 들어간다면 int data = 10 + 10; 에서 20이 도출되었고, 그 data 20을 대입하여 20+ 20 = 40을 또다시 data에 대입한다는 뜻.
	//위 코드에서 data가 반복되므로 data += 20;로 표기한다.(같은말임)
	
	data = 10. / 3.;
	data = (int)(10. / 3.);
	data = (int)(10.f / 3.f);

	// /나누기 연산자는 정수끼리 나눌때는 나머지를 뺀 몫을 구하고, 실수일땐 실수끼리 나눈 몫을 구하는데, 다만 위에 식에서는 int는 정수형 이기 때문에 소수점을 제외하고 정수만 표기된다.
	// 따라서, 위 식은 잘못되었고 data = (int)(10. / 3.); 로 나타내야 한다. 10. / 3. 에 괄호를 같이 한 이유는 괄호를 안한다면 (int)는 정수로 바꾸는 것을 뜻하기 때문에 10.만 정수로 바꾸는 것으로  된다.
	// 그래서 10. / 3. 을 모두 괄호 해야 두개의 값 모두 정수로 표기하게 된다.
	
	//여기서 float f = 10.2415f +(float)20; 의 코드에서 10.2415f 에 붙은 f는 10.2415를 float타입 즉 4바이트 실수 자료형으로 보겠다는 의미이고
	//data = (int)(10. / 3.);에서 10.과 3.의 실수에는 f를 표기하지 않았기 때문에 여기에는 double타입 즉 8바이트 실수 자료형으로 보겠다는 의미이다.
	//정리하자면, 실수를 상수로 적을 경우 소수점 뒤에 f를 붙이면 float 자료형으로, f를 붙이지 않으면 double 자료형으로 간주한다. ex > 0.1f;, 0.1;

	//%모듈러스 연산자는 나머지 값을 구하는 연산자로 data = 10 % 3; 의 경우에는 1이 된다.
	//다만 실수끼리의 나머지는 존재하지 않으므로 피연산자가 모두 정수여야 한다.

	data = 0;
	data++;
	data++;

	// ++ 한단계 증가한다. / -- 한단계 감소한다.
	//단계가 증가한다고 한 이유는 기본 숫자타입의 자료형에서는 +1 또는 -1 형태로 증가 감소하는 것이 맞으나, 나중에 배울 자료형에서는 +1과 -1의 형식이 아니기 때문.

	++data; //전위(전치)
	data++; //후위(후치)

	//++이 앞에 붙을경우 우선순위가 빠르고, ++이 뒤에 붙을경우 우선순위가 느리다.

	a = 10;
	data = a++;
	data = ++a;

	//따라서 위의 경우 ++의 연산은 제일 나중에 시행된다. 따라서 대입연산자가 ++의 증감연산자보다 먼저 시행되므로 a = 10이 먼저 대입된다. data에는 대입연산자가 먼저 되기 때문에 10이 대입되는것
	//그러면 아래 의 경우는 ++이 먼저 시행되기 때문에 +1+10이 되어서 11이 된 후 대입연산자가 시행되어서 data에는 11이 대입된다.
	
	data = 0;
	data--;
	--data;
	//위와 같이 굳이 전위인지 후위인지를 따질 필요가 없는 상황에서는 전위로 하는것이 좋다. 이유는 지금 이해못함.전위로 하는 버릇을 들이자.

	//논리 연산자
	// !(역), &&(곱,and), ||(합,or)
	//참(true), 거짓(false)
	//참 : 0 이 아닌 값, 주로 1
	//거짓 : 0


	// ! 반대,반전, &&는 교집합 , || 합집합
	int truefalse = true;
	//라고하면 true는 주로 1이기 떄문에 변수에는 1이 들어간다.
	int truefalse = false;
	//라고하면 flase는 0이기 때문에 변수에는 0이 들어간다.
	bool truefalse = false;
	
	bool istrue = 100;
	//참거짓 전용 자료형으로 bool이 있다. bool은 참거짓에만 사용되며 굳이 따지자면 정수형이지만 정수형으로 분류되긴 힘들다. 그이유로는 아래 bool istrue = 100;을 시행하면 0이 아닌값이므로 true 로 판단하기 때문에 100이 아닌 1로 받아드린다.
	//참고로 사이즈는 1byte 이다. bool과 false true 에 경우에는 C에는 없고 C++에서만 다룬다.

	istrue = true;
	istrue = !istrue;
	//변수에 true가 들어갔는데 그 다음에 !(반전)을 했으므로 false가 된다.

	bool itrue = 0;
	itrue = !itrue;
	//변수가 0이면 거짓. 거짓의 반전이므로 참이 된다. 이때 참은 1로 보기때문에 결과값은 1이다.

	itrue = 100 && 200;
	//100, 200 둘다 참이므로 연산 결과는 참. 따라서 결과값은 1

	itrue = 0 && 200;
	//일 경우 0은 거짓, 200은 참이므로 교집합에의해 결과는 거짓. 따라서 결과값 0

	itrue = 0 || 300;
	// 0은 거짓, 300은 참이지만 둘중 하나만 참이면 되므로 결과는 참. 따라서 결과갑 1

	itrue = 0 || 0;
	//둘다 0이므로 둘다 거짓이므로 결과도 거짓. 따라서 결과값 0

	//비교연산자
	// ==, !=, <, >, <=, >=,
	// == 는 같은지 , !=는 다른지 물어보는 것.<는 오른쪽이 큰지, <=는 오른쪽이 크거나 같은지
	//이에 대한것을 참과 거짓으로 나누어 대답해줌.

	//논리연산자와 같이 자주 사용되는 것들
	//1. 구문
	//if, else
	data = 0;
	if (100 && 200)
	{
		data = 100;
	}

	// if만약 참이라면 data=100 따라서 100 && 200은 참이므로 data에 100이 들어간다. 0 && 200 일경우에는 거짓이므로 data에 0이 들어간다.
	if (data == 100)
	{
		//if 가 참인 경우 수행
	}
	else
	{
		//if 가 거짓인 경우 수행
	}

	int iTest = 20;
	if (iTest == 10)
	{

	}
	else if (iTest == 20)
	{

	}
	else
	{

	}
	//위 식처럼 if로 만약에~해서 구문을 물어보고, 거짓이 떳다면 else if구문으로 여러번 재질문하는형식.(else if의 갯수는 무한정으로 할 수 있다.) else if 구문까지 다 했는데도 거짓이라면 마지막 else구문으로 거짓인 경우를 수행
	//마지막 else구문이 없다면 아무것도 수행하지 않음. 
	//ex> if 만약 w를 누르고 있다면 캐릭터를 위로 이동해라. s는 아래, a는 왼쪽, d는 오른쪽으로 설정을하고 구문을 위와같이 else if 구문으로 나눴다면 if~else if~ else까지 한셋트이기 떄문에 동시입력이 안된다.
	//따라서 w를 눌러서 참이된다면 그것만 수행하므로 캐릭터는 위로가고 s를 눌러 if구문에서 거짓, 그 후 else if에서 참이 나오므로 캐릭터는 아래로 가게되지만, w a 를 동시에 눌렀을 경우 if구문에서 w가 먼저 참이되므로 캐릭터는 위로만간다.
	//이럴경우 else if가 아닌 모든 구문을 if로 바꾼다면, 별개의 구문으로 보기 때문에 w a를 같이 누르면 w참 a참이므로 캐릭터가 위,왼쪽으로 이동 하게된다. 
	
 
	//switch case
	switch (iTest)
	{
	case 10:

		break;
	case 20:

		break;
	default:

		break;
	}

	//switch case와 if else 와 매커니즘은 비슷
	//if else는 가독성이 떨어지나, 변수나 복잡한 특정값을 넣어야 하는 경우엔 if else 구문으로 나타내는게 더 좋음
	//따라서 상황에 따라 if else와 switch case를 각각 사용함.
	//switch case에서의 주의사항은 위 구문에서 iTest 변수가 20일경우 참이므로 case 20에서 수행이 되는데 이때 중간에 break가 없다면, case 20부터 default까지 모든 구문을 수행하게된다.
	//따라서 break를 입력하지 않으면 문법상 문제가 되지 않으므로 오류 경고창이 안뜨게되고 실수로 내가 break를 입력하지 않았을 경우 내가 의도한대로 프로그램이 실행되지 않고 오류가 뜨지만 왜 그렇게 됐는지 문제점을 찾을때 애먹을 수 있음.
	//case 10, 20, 30 을 모두 한동작으로 수행하길 원할 때, 위와같이 break를 쓰지않고 case 10;, case 20;, case 30;을 입력하는 경우가 있음. 이 경우엔 if 구문으로 바꾸면 if(iTest == 10 || iTest == 20 || iTest == 30) 과 같음.


	//삼항연산자
	// :?
	
	iTest == 20 ? iTest = 100 : iTest = 200;
	//iTest 가 20과 동일하나? 참일경우 100 / 거짓일 경우 200을 수행한다.
	//아래 if 구문과 동일한 뜻이나, 명확성과 가독성이 if구문으로 썻을때가 좋으므로 삼항연산자는 잘 사용되진 않는다.

	if (iTest == 20)
	{
		iTest = 100;
	}

	else
	{
		iTest = 200;
	}



	//비트연산자
	//쉬프트 <<, >>   비트를 화살표 방향으로 한칸씩 민다.
	unsigned char byte = 1;

	byte << 1;
	// 10진수에서 2가 20이 되면 10배, 2진수에서 1이 10이되면 10진수로 나타내면 1이 2가 되는것이므로 2배
	//따라서 2진법에서 비트를 앞으로 하나씩 민다는건 2배가 된다는뜻

	byte <<= 1;
	//일경우 우선순위로 인해 대입연산자가 나중에 수행되므로 2배를 시킨 것을 대입시킨다. byte = byte <<1; 와 같은말

	byte <<= 2;
	//일경우는 4배 시킨것, byte <<= 3; 은 8배

	byte >>= 1;
	//2분의1배 일경우 나머지는 계산 x 한마디로 2로 나눈 몫을 구한다.

	//비트 곱(&), 합(|), xor(^), 반전(~)
	//비트단위로 비트끼리 하나씩 하나씩 참거짓을 가려냄
	// ex> 1011 0111/ 1110 1111 을 비교하여 비트곱(&)일 경우 둘다 1일경우 참(1), 하나라도 0일경우 거짓(0)이므로 1010 0111
	// ex> 1011 0111/ 1110 1111 비트합(|) 일 경우 둘중 하나라도 1일경우 참(1), 둘 다 0일경우 거짓(0) 따라서 1111 1111
	// ex> 비트 반전인 경우는 비트를 반대로 수행한다. 1011 0111 을 반전하면 0100 1000 
	// xor의 경우는 각각의 비트가 같으면 0, 다르면 1로 본다. ex> 1011 0111/ 1110 1111 을 xor연산하면 0101 1000 

	//이런 비트연산자가 어디에 사용되는가?
	// #(전처리기) : 샾이라는 구문으로 작성한 전처리기 단계에서 수행될 수 있는 명령어로 이 명령어는 모든 컴파일 과정중에서 제일 먼저 처리된다.
	//#define : 내가 지정한 구문을 특정 숫자로 치환해준다.

#define HUNGRY 1 //배가 고프다 했을때 1로 보겠다.
	int iStatus = HUNGRY; //헝그리를 1로 보기로 했으므로, 1로 치환해줌.

	//사용하는 이유 : 1. 가독성이 좋다. 숫자로 나타냈을때와 HUNGRY로 나타냈을 때 이 구문이 상태창에 대한것이라는 것, 어떤 디버프라는 것을 한눈에 알기쉽다.
	//                2. define HUNGRY 3으로 수정시 편하다. 일일히 수정할 필요가 없고, define 매크로에서 숫자만 바꿔서 수정해주면 전체 코드에서 적용된다.

	int iStatus = HUNGRY;
#define THIRSTY 2
#define TIRED 4
#define HOT 8


	//int는 4byte이고 총 32bit이다. 특정 상태를 나타내기 위해선 참,거짓 예를들어 배고픔의 상태를 나타내기 위해선 배고픔, 안배고픔과 같이 2가지의 형식으로 이루어진다.
	//따라서 특정 상태를 표현하기 위해선 겹치지 않는 각각의 비트가 필요하고, int에서 32bit가 확보되므로 동시에 표현할 수 있는 상태가 32가지이다.
	//HUNGRY 는 1 이므로 우측에서 1번째 비트를 사용하는 것이고, THIRSTY는 2이므로 2번째비트, TIRED는 3번쨰비트만을 사용하기 떄문에 2^n 형태의 숫자로 배정해줘야한다.
	//이렇게 하다보면 32,64,128 등등으로 나타내기 때문에 가독성을 위해서 16진수로 표기한다. 16진수는 0~9 a~f 까지 16개이다.

#define THIRSTY 0x001
#define THIRSTY 0x002
#define THIRSTY 0x004
#define THIRSTY 0x008

#define THIRSTY 0x010 // 15인 f를 1초과한것이 16이기 때문에 10이다.
#define THIRSTY 0x020
#define THIRSTY 0x040
#define THIRSTY 0x080

#define THIRSTY 0x100
#define THIRSTY 0x200
#define THIRSTY 0x400
#define THIRSTY 0x800

	//위와 같이 16진법으로 나타내면 규칙성이 나타나 가독성이 좋고 정리하기 좋다.

	iStatus |= THIRSTY;
	iStatus |= HUNGRY;
	// 배도 고프고 목이 마르다는 상태.

	if (iStatus & THIRSTY)
	{
		//상태창에 목마름 비트만 적용. 2번 비트가 1일경우 목마름 0일경우 목마름x
	}



	//특정 자리 비트 제거

	iStatus &= ~THIRSTY; //THIRSTY에 해당하는 부분만 비트가 제거됨. 진행방식은 THIRSTY 비트를 반전 후 곱연산에 의해 대입.  ex> 목마름이 없어지면 디버프창을 제거하고 싶을때 사용



	//변수
	//1. 지역변수
	//지금까지 공부하면서 적어온 코드들은 int main () { } 구문 안에 들어가는 코드이다. 이러한 것을 함수라고 한다. 따라서 우리는 main이라는 함수 안에 코드를 작성하고 있는것
	//이러한 괄호 안(함수 안)에 선언되어 있는 변수들을 지역변수라고 부른다.
	
	//2. 전역변수
	//반대로 괄호 외부(함수 바깥)에 선언되어 있는 변수들을 전역변수라고 부른다.
	
	//3. 정적변수
	//4. 외부변수


	//함수(funtion)
	//기능 하나하나를 각각의 함수가 담당한다.
	//작은 기능이 모이고 모여서 이 모든 기능을 포괄하는 함수가 하나의 컨텐츠가 된다. (기능의 모듈화) ex> 캐릭터의 커스터마이즈를 담당하는 함수 -> 그안에는 수많은 기능들이 내포되어 있다.

	//지역변수는 괄호 안에 선언된 변수(함수, 지역) 로 함수안에 지역을 또 나눌 수 있다.
	int iName = 0;
	
	{
	
		int iName = 100;      

		iName;
	}

	iName;
	//변수명 규칙
	// 위와 같이 함수 바깥에 iName의 변수를 정의했고, 함수안에 지역에서 한번더 iName을 선언했는데, 이 때 둘의 변수는 다른것을 나타낸다.
	//따라서 함수안에 지역변수는 같은 지역안에 변수를 우선순위 하고 있기 때문에, 함수안 iName;은 함수안 int iName = 100; 식에 변수를 지칭한다.
	//만약 함수밖에 int iName = 100; 을 선언하면 함수밖에 같은 이름의 변수가 2개를 선언한것이므로 오류로 인정한다.







		return 0;
}