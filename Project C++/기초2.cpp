#include <stdio.h>  //standard input output 이라고 해서 표준입출력 함수가 구현되어 있는 기능. 을 가져오겠다 라는뜻.
#include <wchar.h>





int Add(int a, int b)
{
	return a + b;

}

//함수
int main()
{
	int iData = Add(100, 200);


	// 위 2개의 함수에서 main함수가 먼저 실행이 되고 이어서 iData에 관해 Add가 시행되는데, 이는 다른 함수인 Add함수에 의해 a+b가 되어 300이 대입된 후 Add 종료.
// 모든 작업이 마무리한 후 return 0;에 의해 반환되고 main함수는 할 일을 다 했으므로 역할 끝 종료.
// 그렇다면, 함수가 끝나도 프로그램이 꺼지지 않도록 방어할 수 있는 수단은 ? 프로그램을 유지하는 장치?


	//반복문
	//for()
	for (/*반복자 초기화*/; /*반복자 조건 체크*/; /*반복자 변경*/)
	{

	}

	//반복자 초기화 : 반복자로 지정한 변수를 초기화시켜준다.
	//반복자 조건 체크 : 변수가 특정 조건을 만족할동안 계속 반복문을 반복한다. 조건에 부합되지 않을 경우 멈춤.  따라서, 참 일경우 돌아가고, 거짓일 경우 멈춤.
	//반복자 변경 : 반복자로 지정한 변수가 변경이 되어야 무한반복이 아닌, 원하는 값을 도출할 수 있다.

	for (int i = 0; i < 10; ++i)
	{
		printf("Output Test\n");  //입출력 함수로 프로그램이 시행되었을 때 cmd 창이 뜨는데, 그 창에 내가 원하는 문장을 띄울 수 있게 해준다. 여기서 \n은 다음줄로 넘어가라는 뜻으로 이 반복문에서는
		                          //Output Test라는 글자가 입력되고 다음줄로 넘어가고 이것을 10번 반복하므로 10째줄까지 Output Test가 남겨진다.
	}


	//while()

	while (/*조건체크*/;) // while은 for문처럼 반복자를 따로 관리하지 않는다. 직접 선언해서 해야하므로 조건 설정에 대하여 더 자유롭다.
	{

	}

	// while은 for문처럼 반복자를 따로 관리하지 않는다. 직접 선언해서 해야하므로 조건 설정에 대하여 더 자유롭다. 조건에 맞으면 참, 아니면 거짓

	int i = 0;
	while (i < 2)
	{
		printf("output test\n");

		++i;      //i는 0이므로 참, output 출력 후 i에 +1 -> 반복 -> 반복 -> i는 2 이므로 거짓. 종료.
	}
	
	//반복문 내부에서만 쓸 수 있는 키워드
	//continue(다음반복문 시행) , break(종료) -> for, while 둘 다 사용 가능.
	for (int i = 0; i < 4; ++i)
	{
		if (i % 2 == 1)          // 홀수를 뜻함.(2로 나눈 나머지가 1일경우)
		{
			continue;            //if구문에 해당하면 continue 한다. 즉 continue 다음 구문에 있는 것들은 시행하지않고 바로 다음 반복문으로 넘어가도록함.
		}                       // break 였다면 더이상 반복문을 시행하지 않고 종료시킨다. 끄읕.

		printf("Output Test\n");


	}

	//문자 입출력 : 콘솔창(명령 프롬프트)에 원하는 명령어(문자열)을 띄워보는 기능
	//printf (출력)
	printf("abcdef %d \n", 10);  //%d 자리에 다른 정수를 치환하겠다는 뜻
	printf("abcdef %f \n", 3.14f);  //%f 자리에 다른 실수를 치환하겠다는 뜻

	for (int i = 0; i < 10; ++i)
	{
		printf("Output i : %d \n", i);
	}
	

	//scanf (입력)
	int  iInput = 0;
	scanf_s("%d", &iInput); //%d(정수타입)의 데이터를 iInput(변수)에 입력받겠다는 뜻
	                        //디버그 실행하면 콘솔창에서 입력을 기다린다. 콘솔창에 정수 테이터를 입력해주면 실행된다.


	//함수의 관하여
	//후입선출(나중에 들어온게 먼저 나간다)/ 선입후출(먼저들어온게 나중에 나간다) 구조를 가지고 자료를 관리하는 것을 스택(stack)이라고 하고, 함수의 구조또한 이와 같다.
	//제일 먼저 시행되는 main함수를 실행하면 main함수안에 다른 자잘한 함수들이 호출되어 시행되고, A~Z까지 자잘한 함수들이 모두 시행이되어야 비로소 main함수가 온전히 시행된 후 종료되는 후입선출구조.
	//별개의 내용으로 선입선출, 후입후출 구조로 데이터를 관리하는 것을 큐(Queue)라고 한다.
	
	//함수가 사용하는 메모리 영역
	//스택 메모리 영역
	//-> 함수와 코드는 스택메모리영역에서 메모리 일부분을 어떻게 사용할지, 없앨지 등등을 나타낸 명령어일뿐 함수와 코드자체가 메모리 영역이라고 생각하면 안된다.


	//Factorial : 1부터 n까지의 정수를 모두 곱한 것
	//8! : 1*2*3*...*8


	int i = 8;

	int iValue = 1;
	
	for (int j = 0; j < i - 1; ++j)
	{
		
		iValue *= (j + 2);                  //*= 양쪽 곱한 후 변수에 대입한다.
	}




	return 0;
}

//재귀함수 : 자기 함수 안에서 자기 자신과 동일한 함수를 다시 호출하는 형태의 함수
// -> 탈출 조건이 없다면 자기 함수를 계속 불러오게 되므로 무한반복이 되어서 스택메모리에 함수가 쌓여만가고 사라지지 않기 때문에 결국 메모리 최대치를 초과하여 오류가 난다.
// 가독성이 좋고, 구현이 용이하다.  //성능이 떨어진다.

//재귀함수 팩토리얼

int Factorial_Re(int _iNum)
{
	if (1 == _iNum)
	{
		return 1;
	}

	return _iNum * Factorial_Re(_iNum - 1);  //팩토리얼은 (n * (n-1)!)의 형태

}

//피보나치 수열
// 1 1 2 3 5 8 13 21 34 55 .....

int Fibonacci(int _iNum) //피보나치 반목문버전
{
	if (1 == _iNum || 2 == _iNum)
	{
		return 1;
	}

	int iprev1 = 1;
	int iprev2 = 1;
	int iValue = 1;

	for (int i = 0; i < _iNum - 2; ++i)
	{
		iValue = iprev1 + iprev2;
		iprev1 = iprev2;
		iprev2 = iValue;

	}

	return 0;

}

int Fibonacci_Re(int _iNum)
{
	if (1 == _iNum || 2 == _iNum)
	{
		return 1;
	}

	return Fibonacci_Re(_iNum - 1) + Fibonacci_Re(_iNum - 2);  // 피보나치 수열은 f(n-1) + f(n-2)의 형태

}


int main()
{
	//배열
	//메모리가 연속적인 구조.
	int iArray[10] = { };      //배열의 이름 iArray , int 자료형 10묶음 [10], 10개의 각각 요소들의  초기값.{ }-> { }는 전체를 초기값 0으로 넣는다는 얘기.
	int iArray[10] = { 1, 2, 3, 4, 5, 6 }; //1~6까지 초기값이 들어가고 나머지는 모두 초기값 0이 들어간다.


	// 배열안에 있는 여러개의 인덱스중에 하나에 인덱스에 관여하고 싶을때

	iArray[4] = 10;       //[]의 숫자는 인덱스를 지칭하는 것으로 4번째의 배열이 아님. 인덱스는 0부터 시작하므로 iArray[4]는  5번째 배열을 나타냄.
	iArray[0] = 20;       //접근 가능한 최소 인덱스
	iArray[9] = 30;       //접근 가능한 최대 인덱스
	iArray[12] = 40;      //초과한 인덱스 이지만, 오류가 안날수도있음. 메모리가 연속적인 구조라서 ㅁㅁㅁㅁㅁㅁㅁ식으로 연속적으로 메모리 분배가 되는데,
	                      // 인덱스 9까지 분배가 끝났지만 인덱스 12값을 40주겠다고 설정했으니 이를 메모리상 인덱스 12자리가 위치한 곳에 대입을 시키게되는데
	                      // 우연찮게 그곳에 다른 함수가 자리하고 있으면, 그 함수에 40을 대입시키게 된다.
	                      // 따라서, 인덱스 12가 아니지만 인덱스12값을 대입하므로써 시스템상으론 오류가 없게되지만, 실행하면 내가 원하는 함수값이 나오지 않게되므로 이와 같이하면 오류를 찾아내기도 힘듬.


	//포인터(중요!)


	return 0;

}


//구조체
//사용자 정의 자료형 -> 자료형이란 데이터타입을 설명해줌.
typedef struct _tagMyST     //typedef : 타입디파인, 타입을 재정의한다뜻.
{                           //struct : 구조체
	                        // C++, C언어 둘 다에서 가능한 사용자 정의 자료형 형식
	int a;
	float f;
}MYST;              //int와 float을 묶어서 하나의 사용자 정의 자료형인 MYST를 만듬.
                    //int(4) , float(4) 가 합쳐졌으니 총 8byte 의 자료형.
                    //int a 와 float f에서 a와 f는 변수가 아닌 int 자료형, float 자료형의 이름으로 생각하면된다.
                    // 위 함수는 내가 만든 함수이므로 아직 실체가 있는 함수가 아닌, 자료형을 설명하는 함수이므로 변수가 선언된 것이 아니라는 뜻.

struct _NewST         // C++에서만 가능한 사용자 정의 자료형 형식
{
	int a;        //--> int a; 에서의 a는 일반적으로 변수라고 생각하지만 구조체안에서는 다르다.
	short s;     //--> 구조체 내부를 구성하는 int a; , short s;를 멤버라고 얘기하고, 이 구조체를 가져와 선언한 것이 변수이다. ex> _NewST s2; <--변수

};

_NewST s;          // 타입을 재정의 안해줘도 구조체 정의가 되어서 사용가능 그러나 C++이 아닌 C언어에서는 구조체라는 struct안에서 정보를 찾아야 하기 때문에
                   // struckt _NewST s; 로 써줘야 사용가능하다. 


int main()
{
	MYST t = { };  // 배열파트에서 설명했듯이  = { } 할경우 초기값으로 0을 넣는다는 것이 똑같이 적용됨.
	MYST t = { 100, 3.14f };    // MYST 정수파트인 a에 100을 , 실수파트인 f에 3.14를 넣으라고 초기값을 적용시킴.

	t.a = 10;            //a는 int 파트(정수) --> a는 구조체 안에 구성된 정수파트 멤버의 이름
	t.f = 10.2312f;      //f는 float 파트(실수)  --> f는 구조체 안에 구성된 실수파트 멤버의 이름.

	int isize = sizeof(MYST); //sizeof() : ()안에 데이터 사이즈값을 변수에 대입.
	
	return 0;

}

//변수의 종류
//1. 지역변수
//2. 전역변수
//3. 정적변수(static)
//4. 외부변수(extern)

//메모리 영역 (C++은 메모리를 직접 다루기 때문에 중요함)
//1.스택 영역 : 지역변수가 사용
//2.데이터 영역 : 전역,정적,외부 변수가 사용하는 영역
//3. 읽기 전용(코드, ROM)
//4. 힙 영역






//전역변수
//전역변수는 지역변수와 사용하는 메모리 영역이 다름.
int g_i = 0; // 전역변수가 사용하는 메모리 영역은 Data 영역 이라고한다.

//Data 영역 특징
//프로그램 시작 시 생성
//프로그램 종료 시 해제

void Test() //함수가 반환값이 없을 경우 void 함수를 사용
{
	++g_i;      //g_i는 전역변수 이기 때문에, 프로그램 시작 시 생성되었고, 프로그램이 종료 시까지는 데이터 영역에 계속 상주하고 있기 때문에 void Test 함수가 관여할 수 있음.
	a = 100;    // a는 main함수 로컬안에서 선언한 지역변수 이므로, 서로 다른 로컬에 있어서 관여할 수 없음.
	
}

int main()
{
	int a = 0;
	Test();     //Test안에 함수식이 int i = 0;  ++i; 라면 Test(1), Test(2)와 같이 늘어난 변수값이 적용될것이라고 생각하지만
	Test();     //Test함수가 호출되면 스택메모리에 Test함수가 생성되고, 함수를 수행한 후 종료된다. 그러면 Test함수안에서 형성된 변수 i는 0을 넣고 1을 증가시킨후 종료 된것과 같다.
	Test();     // 따라서 Test 함수가 종료되어서 지역변수 i도 같이 소실되버리고, 다음 Test()에서 같은 작업을 반복하므로, 수치는 증가하지 않는다.
	
	g_i = 0;

	return 0;
}


//분할구현
//함수의 순서
//위 함수식을 반대로 한다면?

void Test();

int main()
{
	int a = 0;
	Test();
	Test();
	Test();

	g_i = 0;

	return 0;

}


void test()
{

	++g_i;

}

//이렇게 반대로 한다면 코딩은 위에서부터 시작되기 때문에 순서대로 내려오면 main함수에서 Test함수를 호출했지만 호출된 Test함수가 main함수보다 뒤에 있기때문에 호출되지 않는다.
//따라서 문법적으로 문제가 되므로 컴파인단계에서 오류가 나게된다.
//그래서 main 함수 앞에 void Test();을 함으로써 Test함수가 있다라고 선언을 해놓는것. 이렇게 되면 main함수는 void Test라는 함수가 있다라고 인식하게됨.
//컴파인단계에서는 문법적으로 오류가 없기 때문에 통과되고, 이후에 링크단계에서 앞에서 선언했던 Test함수가 뒤에 나오는 Test함수와 같구나!라고 생각하고 둘을 연결지어서 마무리를 하게된다.
//만약 앞에서 Test를 선언했는데 뒤에 Test함수식이 등장하지 않는다면 링크단계에서 Test함수가 있다고 해서 넘어왔는데 다 찾아봐도 없는걸? 하면서 오류가 생기게됨.


//헤더(.h)와 소스(.cpp)의 관계
//헤더는 함수식의 선언을 담당한다.              ex> void Test();   int Add(int a , int b);
//소스는 함수식의 실체,정의, 함수식을 담당한다. ex>int Add(int a, int b)
//                                                {
//                                                       return a + b;
//                                                }

//위의 void Test로 선언을 미리 해놓고 나중에 함수식이 링크단계에서 연결되듯이 헤더를 참조하여 함수식을 미리 선언하고, 다른 cpp파일에 함수식(정의)이 존재한다면, 다른파일에 있는 cpp파일에서
//그 함수식을 가져와 사용할 수 있음.
// 
// ex> 기초2.cpp 파일에서 main함수에서 Add함수를 사용해야할 때, #include "func.h" 를 함으로써 Add함수를 선언한 헤더파일을 가져온다. 따라서 main함수에서의 Add함수는 선언한 함수이기 때문에 실체를 없지만
// 컴파인 과정에서 문제될 게 없다. 다만, 프로젝트 전체(exe)을 많은 cpp파일이 구성되고, 디버깅,실행 할 때 전체가 모두 작동되기 때문에 링크단계에서 Add함수가 포함된 cpp파일을 검토 후 Add함수식을 main함수에 적용시킨다.
// 다만, Add함수식을 구현해놓지 않았다면, 헤더를 적용시켰어도, 링크단계에서 찾아서 연결해주지 못하므로 링크단계에서 오류가 발생한다.
//이를 이용해 func.h에 수많은 함수를 선언하고, func.cpp에 그 함수의 함수식을 작성한다면, 다른 cpp파일에서 사용하고 싶을때 include로 헤더파일을 가져오기만 한다면 어디서든 사용 가능하다.
//이렇게 헤더와 cpp를 잘 분할구현 해놓으면 코드를 손쉽게 관리할 수 있음.


//분할구현의 문제점
//헤더 파일에 선언뿐 아니라 함수의 정의까지 구현해놓으면 안되는건가?


void Name()
{

}
void Name()
{

}
 //위와 같이 Name 함수를 두 번 작성하면, 중복으로 나중에 다른 함수에서 Name 함수를 호출했을시 위 함수를 호출하는지, 아래 함수를 호출하는지 모호해지므로 오류가 뜬다.
 //헤더에 함수 정의까지 구현해놓으면 각각의 cpp파일들이 헤더 함수식을 가져와서 사용할 때, 컴파일 단계에서는 통과가 되지만, 링크단계에서 하나의 exe로 합쳐질 때, 각각의 파일에서
 // 헤더 함수식에서 가져온 함수를 모두 가지고 있기때문에 중복이 되어버려서 오류로 인정한다.
 //또한 이렇게 되면 애초에 함수를 사용하는 이유는 코드 재사용하기 위함인데, 헤더에 함수정의가 들어가는 순간 매 순간 함수정의식을 복사 붙여넣기해서 재사용 하는것이므로 매번 필요할때마다
 // 그 함수를 똑같이 입력하게 되는 것과 같다. 따라서 헤더에는 함수의 선언만을 , 다른 cpp파일에 함수의 정의를 구현해놓는것이 바람직하다.

//분할구현을 사용하면 헤더를 통해 서로 다른 파일에 대하여 함수에 접근이 가능해진다.
//그러나, 코드,함수 생선단계(내가 코드짤 때)에서 한 파일(main.cpp)에서 선언한 전역변수를 다른 파일(func.cpp)에서는 사용하지 못한다. 그 이유는 파일 단위로 컴파일 과정을 거치는데, 이 과정에서 main.cpp에서 선언한 전역변수 값을
//func.cpp에서 인식하지 못하므로 만약 코드를 짤 때 func.cpp에서 main.cpp에서 사용된 전역변수를 가져왔다면 오류를 범하게 된다. 그러나 데이터 영역에는 전역변수의 메모리영역이 존재하고 있긴 함.
// 한마디로 내가 선언한 전역변수를 다른쪽 파일에서 인식시키기가 힘들다.

// 그렇다면 헤더에다가 전역변수를 선언하면 되지않음?
// 그렇게 되면 헤더를 통해 전역변수를 다른 파일이 참조하여 사용할 수 있긴하다. 그러나 근본적인 오류가 생기게 되는데, 컴파일 단계에서는 문법적으로 문제점은 없다.
// 각각의 cpp파일의 컴파일을 끝나고 나면 전체 파일을 하나로 합치고 연결하는 링크단계에서 합치고 나고 보니 결과적으로 하나의 프로젝트에 같은 전역변수 선언이 3개나 되는것.
// 따라서 헤더에는 변수선언은 불가능하고, 함수의 선언만 가능.

//요약하자면 헤더에서는 이런 함수가 있다고만 선언해 논 함수의 선언만 필요하다. 이를 보완하기 위해 정적변수/외부변수라는 개념이 도입된다.


//정적변수 : 키워드(static = 고정된)
//-> 생성된 곳에서 벗어나지 않음. -> 기초2.cpp에서 선언된 정적변수는 선언된 그 파일안에서 벗어나지 않으므로, func.cpp에서 같은 이름의 정적변수를 선언하여도 그 또한, func.cpp 파일안에서 벗어나지 않는 변수로
//이름은 같지만 각각의 변수가 지칭하는 것이 정해져있게되어 구별할 수 있게된다.

static int g_iStatic = 0;

void Test()
{
	static int i = 0; //Test 함수 안에서 선언되었으므로, 정적변수 i 는 Test 함수 안에서만 존재한다.
	                  //Test 함수는 스택메모리를 사용하는데, 정적변수는 데이터영역을 사용한다.
	                  //따라서 이와같이 선언됐을 경우, 정적변수 i는 데이터 영역에 생성되지만, 사용은 Test함수 안에서만 사용가능하게된다.
	                  //또한, 데이터 영역은 프로그램이 종료시까지 없어지지 않으므로, Test함수(스택)가 종료되어 사라져도, 정적변수 i는 데이터 영역에 계속 남아있게 된다.
	
}


//외부변수 : 키워드 (extern)
extern int g_iExtern;   //다른 변수와 달리 선언할때 초기값 0을 주면 안됨.
                       //분할구현 때와 똑같음. g_iExtern이라는 변수가 존재한다고 선언만 해둔것. 컴파일 단계에서는 이런 변수가 존재한다고 하니 이 변수를 사용한 함수를 진행시킴.
                       // 이후 링크단계에서 변수의 정의가 작성되있어야 옳바르게 코드가 작성된것이고, 정의가 작성되지 않으면 있다고해서 사용했는데, 없는데?하면서 오류가 생김.
                       //따라서 외부변수의 정의가 결국엔 어떤파일에서건 작성이 되야만한다.
void test()
{
	g_iExtern = 100; //외부변수 g_iExtern 이 앞에 있다고 선언되었고, 뭔지 모르지만 100을 적용시킴.

}

int g_iExtern = 0; //이후에 다른 파엘에서건 변수 g_iExtern는 이것이다. 라고 정의함. 따라서 오류 없음.



//포인터 변수
//주소를 저장하는 변수
// 자료형 + * 변수명  : 포인터 변수 선언방식
//  └> 해당 포인터에게 전달된 주소를 해석하는 단위, 따라서 데이터 타입을 미리 정해논 것.

int* pInt = nullptr;  //nullptr : 아무것도 가리키지 않는다는 의미   0; 와 같음
                      // int자료형 변수를 가르키는 변수 -> int*

int main()
{
	int i = 100;

	int* pInt = &i;       //&i(엠퍼샌드i)의 의미는 i의 주소값을 나타낸다.
						  //따라서 i의 주소값을 pint에 넣겠다.

	(*pInt) = 100;        //*pInt : pInt의 주소로 접근하겠다 -> pInt의 주소는 i 이므로  i에 100을 넣겠다.


	//주소의 단위(byte, 정수표현방식)
	//주소가 100과 102의 사이에는 2byte의 여유공간이 있다. 100 -1byte- 101 -1byte- 102

	//*pInt 면 설정한 주소로 접근하는건데 왜 포인터 변수를 선언할때 Int와 같이 자료형을 같이 선언하는가?
	//포인터 변수는 생성시부터 본인이 받을 주소의 자료형을 미리 정해놓는다. 따라서, Int* pInt 는 Int형 주소만 받아서 주소에 접근할시 4byte만 접근할것이다 라고 선언한것.
	//따라서 pInt의 앞에 적힌 자료형은 포인터 변수가 가리킬 데이터의 타입을 정해놓은 것.

	float f = 3.f;     // 만약 실수형 타입변수 f을 int포인터 변수에 적용시킨다면? 
                       // int포인터 변수는 실수형 주소를 받았지만, 그것을 int로 보기로 했으므로, int로 해석하게된다. 따라서 float에서의 표현된 3이 아닌, 전혀다른 숫자로 결과값이 나오게됨.



	return 0;
}



int main()
{
	int* pInt = nullptr;

	char* pChar = nullptr;     //char가 포인터 변수의 크기를 나타내는 것이 아니고 주소의 데이터 타입을 나타내는 것
	short* pShort = nullptr;   // 그러면 포인트 변수의 크기는 몇임?

	//포인터 변수의 크기
	//os(운영체제) 플랫폼에 따라 달라진다.
	//따라서 플랫폼이 64bit 를 따르면 포인터 변수의 크기는 8byte. / 32bit 를 따르면 4byte.

	int iSize = sizeof(int*);



	//운영체제
	//x86(32bit)->4byte / x64(64bit)->8byte
	//하드웨어(컴퓨터)는 한번에 4byte씩 처리할 수 있는 구조가 되는데, 소프트웨어(o.s)가  한번에 8byte를 처리할 수 있는 명령어를 준다면 처리하지 못함.
	//반대로 하드웨어가 8byte 처리 할 수 있고, 소프트웨어가 4byte 명령어를 주면 쉽게 처리 가능.
	//요즘은 모든 컴퓨터가 64bit 처리를 할 수 있게 나오기 때문에 명령어 작성도 64비트에 맞춰서 작성한다.

	int i = 0;
	pInt = &i;      //pInt가 가리키는 i의 주소지가 100번지라면 i에 해당하는 주소는 int 자료형이므로 100~104번지(4byte크기) 사이이고, 바로 다음 주소지는 104부터 시작된다.

	pInt += 1;      //pInt에 +1을 한다는 뜻은 일반적인 덧셈이라면 100+1라고 생각하겠지만, 여기서 pInt는 주소지를 가리키고 있기 때문에 다음 주소지를 가리켜라 라는 뜻으로 해석해야한다.
	                //따라서 +1을 대입하면, pInt의 주소지는 int자료형타입을 따르므로 4byte이므로 다음주소지인 104가 도출된다.


	//요약 : pInt는 int* 변수이기 때문에 가리키는 곳을 int로 해석한다.
	//       주소값을 1 증가하는 의미는 다음 int 위치로 접근하라는 해석으로 sizeof(int) 단위로 증가하게 된다.

	//포인터와 배열
	//배열의 특징
	// 1. 메모리가 연속적인 구조이다.
	// 2. 배열의 이름은 배열의 시작 주소이다.
	int iArr[10] = {};

	*(iArr + 1) = 10; //iArr배열의 시작으로부터 1칸(int단위 4byte)띈 주소로 접근해라. -> 그리고 그곳에 10을 넣겠다.
	                  //라는건 iArr배열은 연속적이므로 배열 시작으로부터 int단위 1칸 이동하면 바로 다음 iArr배열이므로 iArr[1]에 10을 넣겠다는 의미.(배열은 [0]부터 시작함)
	                  //따라서 배열의 이름 iArr[1]은 배열의 시작 주소*(iArr +1)라는 말이다. 동시에 배열의 인덱스를 0부터 시작하는 이유.
	*(iArr + 2) = 10; // iArr[2] = 10; 와 같음
	                  // 배열[정수] -> *(배열 + 정수)


	return 0;
}




//포인터 문제풀이


int main()
{


	short sArr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	int* pI = (int*)sArr;

	int iData = *((short*)(pI + 2));

	printf("1번 문제 정답 : %d\n", iData);

	//sArr배열의 인덱스는 총 10개이고 쇼트자료형(2byte 정수형)을 따르며, 각 배열의 순서에 따라 초기값이 1~10까지 설정되어있다.
	//포인터변수 pI는 int형으로 해석할 것이고, sArr 배열의 주소를 int형으로 강제 해석할 것이다.
	//이렇게 해서 pl +2의 값을 short로 다시 또 해석하여 찾아낸 주소를 iData에 입력할것이다.

	//pl +2 는 주소지를 2번 이동한것을 말하는데, pl은 int형이므로 총 8byte를 이동한것이고, 이것이 가리키는 주소지는 시작점에서 8byte만큼 간 부분을 뜻한다.
	// 여기서 *(pl +2)라면 pl은 아직 int단위로 봐야하기 때문에, 기존 short sArr배열에서 배당된 메모리 부분인 sArr[4], sArr[5]를 합친 부분이 pl +2 부분이 되어버린다.
	// 값이 2개가 되어 버리기 때문에, 앞에 (short*)로 단위를 다시 맞춰준것. 따라서 (short*)에 의해서 pl+2 주소지를 short 포인터로 바꿔준 후 접근했기 때문에 sArr[4] 영역에 해당된것.
	//따라서 묻고자 하는 값은 sArr[4]= 5

	//정답 5


	char cArr[2] = { 1, 1 };

	short* pS = (short*)cArr;

	iData = *pS;

	printf("2번 문제 정답 : %d\n", iData);

	//char 자료형 1byte, 정수형을 따르는 배열 cArr의 초기값은 1로 설정
	//short로 해석할 포인트 변수 pS, cArr의 해석또한 강제로 short로 한다.
	//*pS; 는 pS포인터로 접근해라. -> pS는 short포인터 이기 때문에, 2byte 접근할것이다. 
	//그러면 결국 2byte로 해석할 것이기 때문에 연속되어 있는 8개 비트를 합쳐서 16비트로 해서 하나로 볼것이다.
	//원래라면 둘다 1이므로 ㅁㅁㅁㅁㅁㅁㅁ1 / ㅁㅁㅁㅁㅁㅁㅁ1로 비트가 생성되있지만 이를 하나로해서 16비트로 볼것이라고 했고, 배열은 연속적이라고 했으니,
	// ㅁㅁㅁㅁㅁㅁㅁ1ㅁㅁㅁㅁㅁㅁㅁ1 의 16비트 형식을 나타낸다. 따라서 256 + 1 = 257이 된다.

	//정답 257



		return 0;

}


void Test(int* b) //변수 a의 주소지
{
	*b = 500;     //int a의 주소지에 4byte정수형 만큼 접근 후 500을 기록.

}

int main()
{
	int a = 100;

	Test(&a);     //Test함수의 변화된 변수값을 적용받고 싶다. 그러나 main함수와 Test함수는 서로 다른 스택영역을 사용한다. 따라서 main함수에서 관여할 수 없음.
	              //그러나 그 함수의 값이 어디서 적용되는지 주소를 알면 적용시킬 수 있음. 그래서 &a로 주소값을 받겠다 라고 하면 Test함수에서도 똑같이 주소값을 입력한다.
	              // 이렇게 되면 서로에게 관여할 수 있게 되므로 Test함수에서 변수에 500을 기록하고 사라지는 것이 아니라 main 함수에 적용이 되어서 a에도 500이 기록되는것.

	printf("출력 : %d\n", a);

	// scanf_s("%d", &a); //scanf 에서 변수앞에 &를 붙인 이유는 이제배운 포인터와 연관되어 내가 입력한 데이터를 변수a의 주소지에 입력되는 것.
	                   //해석 : %d->정수타입으로 &a->접근한 주소지에 scanf 입력한 값을 입력한다.




	//const
	const int cint = 100;

	//상수화 : 값이 바뀔 수 없는 상태가 되었다는 뜻.  -> 이런것들을 r-value라고 한다.
	//r-value : 값이 변하지 않는 값(상수)
	//l-value : 값이 변하는 값(변수)

	pInt = (int*)&cint;
	*pInt = 300;
	printf("cint 출력 : %d\n", cint);

	//cInt는 상수라서 값이 변하지 않지만 이를 강제로 변하게 하기 위해선 주소값으로 가서 값을 입력하는 방법이 있다.
	//따라서 cint 주소값으로 가서 300을 집어 넣으라는 명령을 해주었고, 이를 출력하면 300이 나와야한다.
	//그러나 출력은 100으로 되어있는데, 이 이유는 실제로는 주소값에 300을 입력했기 때문에 cInt 의 값은 300으로 바뀌어있지만, 프로그램이 연산을 할 때,
	//더욱 빠른 접근으로 연산을 하기 위해서, 연산에 관한것들(결과값?)은 레지스트리에 저장을 해놓고 연산될 때 그쪽에 저장된 것들을 가져와서 결과값을 도출하도록 한다.
	//따라서, cInt는 원래라면 상수이고, 변하지 않는 값이므로 이미 결과값은 정해져 있기 때문에 레지스터에 그값인 100을 저장해놨다가 printf가 출력할때 레지스터에서 가져와 출력한것.
	//이를또 강제로 출력하기 위해선 const int cint = 100; 앞에 volatile(휘발성)을 붙이면 지칭한 cint의 값을 레지스터를 사용하지 않고 직접적으로 확인하라는 명령어이다.



	//const 와 포인터
	int a = 0;
	int* pInt = &a;

	*pInt = 1;               //포인터 변수가 가리키는 대상의 변수 a의 값을 바꿈 -> a를 1로 바꿈
	pInt = nullptr;          //포인터 변수가 가리키는 대상을 바꿈 -> nullptr; 더이상 아무것도 가리키지 않음

	//포인터 변수는 받은 주소값안에 있는 변수에 관여하여 바꿀수도 있고, 포인터변수가 가리키는 주소값 자체를 바꿀수도 있는 2가지의 경우가 있다.
	//따라서 const가 포인터에 관여한다는것(포인터변수의 상수화)은 이처럼 2가지 경우로 나뉜다.

	const int* pConstInt = &a;  //앞에 const 가 붙을 경우 : 포인터 변수가 카리키는 대상의 원본을 상수화 -> 다른것을 가리킬 수 있으나, 기존 가리키던 주소값의 원본을 수정 할 수 없음.

	int* const pIntConst = &a;  //뒤에 const가 붙을 경우 : 포인터 변수자체가 상수화 되어 다른것을 가리킬 수 없음.


	//초기화 시 가리킨 대상만 가리킴, 가리키는 원본을 수정 할 수 없음.
	const int* const pConstIntConst = nullptr;  //포인터 변수가 가리키는 대상의 변수 값과 포인터 변수 자체를 둘 다 상수화 시킨다.

	//외우기 쉽게 이해하기! --------> const가 뒤에나오는 수식어를 봐라!
	// const int* pConstInt 는 const가 * <-- 를 수식한다. 따라서 *은 주소값을 나타내므로 주소값이 들어있는 원본을 말한다. 그러므로 원본 자체를 상수화하는것
	// int* const pIntConst 는 const가 pIntConst라는 포인터 변수를 수식하므로, 포인터 변수를 상수화시켜 가리키는 대상을 변경하지 못하게 하는것.
	
	int const* p = &a; // 따라서 int는 앞에있지만 *이 const 직후에 나오므로 const는 *을 수식하므로 주소값 원본을 상수화 한다.


	{
		
		int a = 0;
		const int* pInt = &a;
		
		// a = 100;           -> const가 *을 수식하므로 원본을 수정할 수 없음. 여기서 a에 100을 넣는다는게 const는 pInt라는 포인터 변수가 원본에 수정을 할 수 없도록 제한을 거는 역할이므로
		                       //변수 a하고는 전혀 관련이 없다. 따라서 a에 100을 넣을 수 있다.

		//pInt* = 100;        -> 이식은 포인터변수pInt의 주소값에 100을 넣는것으로 위에서 말한 포인터변수가 가리키는 원본에 수정을 하는 영역이므로 const에 의해 수행 불가능.


	}



	return 0;
}


//Const 포인터의 예시   -> const  포인터는 원본데이터를 바꿀 의도가 없을때 사용.
//아래 예시는 int형포인터이지만 포인터의 크기가 매우 크다거나, 하나만 존재해야 하는 이유가 있을 때 사용되는 예시로 일반적인 상황은 아니다.

void Output(const int* pI)
{
	int i = *pI;
	* pI = 100;    //const라서 제한을 걸어줬으므로 원본 변환 불가능

}

int main()
{
	
	int a = 0;

	a = 100;
	Output(&a);  //const int* pI가 적용되있음으로 이 함수는 원본데이터를 읽기만 하겠다. 수정할 의도는 없다라고 해석할 수 있다.
 
}
//main 함수에서 Output 함수를 호출하게 되면, main 함수에 있는 변수 a의 데이터가 Output에도 복사가되어 결국 a라는 데이터가 main에 1개 , Output에 1개 총 2개가 존재하게 된다.
//데이터가 클 경우 이는 매우 비효율적이게 되므로, Output에 복사붙여넣기가 아닌 main 함수에 있는 a의 데이터를 가져다 사용하고 싶어짐.
//따라서 Output(&a); 로 a변수의 주소값을 보내주고, Output에서는 int* pI에 의해 주소값에 접근한다. 그런데 이럴 경우 main함수에서 뜻하지 않게 a변수의 값이 변경될 수 있는 가능성이 생긴다.
//그 이유는 a의 주소값을 보내줬으므로 Output안에서 a의 주소값에 다른 데이터를 입력하게되면 main함수 a에 그대로 적용이 되기 때문.
//이를 방지하기 위해 const를 사용하여 int* pI가 주소값을 받아올때 원본 데이터에 관여하지 못하도록 제한을 걸어준다.
//그러면 Output 함수 안에서 int i = *pI 와 같이 pI의 값을 가져와서 i에 적용시키는 것은 가능하나 *pI = 100;과 같이 pI 원본값 자체를 바꾸는 식은 허용되지 않는다.


//void : 반환할 값이 없음.
//void 포인터
//1. 원본의 자료형을 특정하지 않음.
//2. 어떠한 타입의 변수의 주소든 다 저장 가능
//3. 역참조 불가능
//4. 주소 연산 불가능
int main()
{
	void* pVoid = nullptr;  //void 함수에 주소를 넣어줬을때 그 주소를 특정 데이터 타입으로 보지 않기 때문에 어떤 데이터타입의 주소던 다 받을 수 있다.
							//다만 이러한 함수를 역참조하는 것은, 반대로 얘기하면 데이터 타입을 어느 하나로 특정해서 볼 수 없기 때문에 역참조는 불가능하다.

	float* pFloat = nullptr;
	{
		int a = 0;
		float f = 0.f;
		double d = 0;
		long long II = 0;

		pVoid = &a;
		pVoid = &f;
		pVoid = &d;
		pVoid = &II;            //모든 데이터타입을 받을 수 있음.


		//*pVoid; //역참조 불가능 : 데이터 타입을 특정 할 수 없음.
		//pVoid + 1; //주소에 몇바이트를 추가해야하는지 특정할 수 없음. 주소 연산 불가능


	}



	//문자
	//char(1), wchar(2) : 문자 전용 자료형
	//char는 1byte의 크기로 표현할 수 있는 가짓수가 0~255로 256가지이다. 근데 실질적으로 8비트중에 맨앞에 있는 비트는 1로 고정되어 있다.(이유는 그냥 그런갑다하자)
	//따라서 7비트로 표현할 수 있는 수는 0~127로 128가지의 문자를 표현 할 수 있다. wchar는 2byte니까 가짓수는 2의 16승이므로 더 많은 문자를 표현 할 수 있다.

	wchar_t wc = 1; // 대응되는 숫자를 아스키코드표에 따라 숫자에 대응하는 문자로 나열됨.
	bool b = 1;

	char c = 1;          //메모리에서의 데이터 1
	c ='1';        //문자로서 '1'   -> 아스키코드에서의 문자 1은 이에 대응하는 데이터값 49.

	wc = 459;        //데이터값 459
	"459";           //문자열 "459" -> 4,5,9 각각에 해당하는 문자는 52,53,57 이므로 각각의 숫자는 1byte=255비트로 표현할 수 있으므로 각각 1byte로나눠서
	                 //3byte안에 1byte씩 나눠서 데이터값 52/53/57 할당. 

	 //그러면 연속된 byte메모리값에서 어디까지가 문자고, 어디까지가 일반적인 메모리데이값인지 모호해지므로, 이를 경계로 구분짓기 위해서 문자열이 끝난 다음 데이터값에 0을 넣어준다.
	 // 따라서 "459"에 들어가야할 메모리값은 52/53/57/0 가 들어가야 한다.
	 // 
	 //메모리 데이터값 0은 문자열로 'NUL'
	 //참고로 스페이스바로 넣어진 공백은 문자로 '32'이기 때문에 NUL과 공백을 헷갈려 하면 안된다.


	//문자열

	char c = 'a';            //1byte 정수의 문자를 넣을 시
	wchar_t wc = L'a';       //2byte 정수의 문자를 넣을 시 -> L은 'a'문자를 2byte로 쓰겠다는 뜻.

	char szchar[10] = "abcdef";          // 1byte짜리 인덱스 배열 10개 선언
	wchar_t szWChar[10] = L"abcdef";    // a~f까지 6개 그리고 마지막에 NUL 문자까지 들어가야하므로 총 7개의 인덱스가 필요
	                                    // 2byte짜리 인덱스 배열 10개 선언 -> 뒤에 L이 붙어야함.

	short arrShort[10] = { 97, 98, 99, 100, 101, 102, }; // 위 2byte 문자열과 같은 뜻으로 기존에 배웠던 배열 함수로 정리한것. 97은 a, 98은 b .... 등등 으로 매칭되고,
	                                                     // 나머지 뒤에는 자동으로 0이 들어가므로 NUL이 들어간것과 같다.

	wchar_t szWChar[10] = L"abcdef";    //스택 메모리에 szWchar배열 10개를 생성 후 그 배열에 abcdef0000...의 값을 각각의 배열에 복사하는 개념.
	const wchar_t* pChar = L"abcdef";   //포인터 변수 pChar가 L"abcdef"의 주소값을 가리킴.

	szWChar[1] = 'z';    //szWChar의 2번째 배열인 b를 z로 바꿔라. --> 이 말인 즉 10개의 배열에 코드에 적힌 문자들을 복사한 후, 그 배열안에 있는 b값을 z로 덮어씌운다는 뜻.
	pChar[1] = 'z';      //pChar가 가리키고 있는 주소값은 코드 L"abcdef"이므로, 코드값은 ROM(읽기전용)이라는 메모리 영역에 존재하는데, 우리가 작성한 코드를 프로그램 실행단계에서 관여하여 코드를 수정하라고
	                     //하는 것과 같으므로 모순이 생기게 된다. 따라서 이와 같은 코드는 실행 불가능.
    // 위 식은 -> *(pChar + 1) = 'z'; 와 같은 뜻으로, 코드 자체를 수정할 순 없다. 

	//따라서 이러한 경우를 방지하기 위해 문자열의 반환타입이 애초에 const 포인터 타입으로 설정해놨음(const로 *가리키는 주소값을 상수화 하므로 원본을 수정할 수 없음. )
	//따라서 문자열의 주소값을 반환하기 위해선 const가 동반되어야 한다.




	char szTest[10] = "abc한글";     //멀티byte 시스템을 사용하므로 abc는 1byte로 배열 3개를 사용하지만 한글은 1byte로는 표현하기 힘들어서 2byte로 표현하게되므로 각각 인덱스 2개씩이 할당된다.
	                                 //이러한 멀티 byte 시스템은 표준으로 사용하지 않는 방식으로 특수한 경우이고 요즘들어 몇몇을 제외하고는 2byte로 표현하는 유니코드 시스템을 사용한다.

	//멀티바이트의 문제점 : 1바이트 문자와 2바이트 문자가 혼재되었을 경우 어떤것이 1바이트인지 2바이트인지 기준이 모호해지기 때문에 이를 구분짓기 위해 비트값에 대해서 어떤 기준을 세워놨는데
	//이를 다 신경쓰기에는 복잡해짐.

	wchar_t szTestW[10] = L"abc한글";  //유니코드 시스템으로 한 인덱스가 2byte로 한 인덱스당 a,b,c,한,글이 각각 배정된다.


	{

		wchar_t szName[10] = L"Raimond";

		int iLen = wcslen(szName);          //wcslen : 문자의 길이를 알려주는 함수 (#include <wchar.h> 참조 필요)
		                                    //문자의 길이를 알기 위해선 배열의 주소값을 알아야함. -> wcslen(szName);


	}




	return 0;
}


unsigned int GetLength(const wchar_t* _pStr)   //문자의 길이를 알기 위해서 이 함수가 받아야 할 것은 문자열의 주소를 받아야 함. 또한, 2byte의 문자열을 사용할 것이므로 wchar_t* 이고, 이를 수정하면 안되므로 const까지 붙인다.
{
	
	//  _pStr[0]; 의 뜻은 main 함수로 치면 szName[0];에 접근한것과 똑같음.
	// 문자열의 규칙중 문자가 끝나면 무조건 NUL문자 (0)이 들어가야 하므로, 반복문을 통해 NUL문자가 나오기 전까지의 문자의 갯수를 세면 됨.
	// 다만, 이러한 반복문의 경우 반복문의 횟수가 정해져 있지 않기 때문에, for 보다는 while에 적합함.
	int i = 0; //while문 안에 선언할 경우 반복문이 돌아가면서 계속 i를 선언 후 초기화하기 때문에 변한 i값이 들어가지 않음.( i는 문자의 갯수 체크 용도)

	while (true)  //조건체크에 true를 해놓으면 반복문 계속 돌리다가 조건에 해당됐을때 break로 탈출조건은 만든다고 쉽게 생각할 수 있다.(조건체크를 걸기 어려울 경우 true부터 넣고보자) 
	{

		wchar_t c = *(_pStr + i); //시작 주소로부터 i번째 칸의 주소로 접근해서 문자를 확인을 해라. 결국 _pStr[i]; 와 같음

		if ('\0' == c)   // \0은 NUL을 뜻함.    //참고로 비교연산 할 때, Rvalue 즉 상수를 왼쪽에다가 입력하는 습관을 들이면 오류감지하기 편함.
		{
			break;
		}

		++i;  //if에 걸리지 않았다면, ++i해서 반복


	}

	return i; //탈출 시 i의 값이 알고자하는 문자의 길이
}

//위 식을 좀 더 정리된 함수로 표현 한다면

unsigned int GetLength(const wchar_t* _pStr)
{
	int i = 0;

	while ('\0' != _pStr[i])   //시작주소로부터 i번째 인덱스에 저장된 문자(_pStr[i])가 \0 (NUL)이 아니라면으로 조건체크. != 는 다른지를 체크하는 비교연산자.
	{

		++i;    //!=로 다른지를 체크했으니 NUL이 아니라면 ++i
	}


	return i;

}


int main()
{

	wchar_t szName[10] = L"Raimond";

	int iLen = GetLength(szName);

	//문자열 이어 붙이기

	wcscat_s(); //()안에 함수 선언을 보게되면(단축키 참조) wchar_t *_Destination, rsize_t_SizeInwords, const wchar_t*_Source 로 나오는데
	            //                                         이부분은 Destination(목적지)로 이어 붙임을 당하는 부분
	            //                                                                SizeInwords(문자의 갯수) 이어 붙일 문자의 갯수
	            //                                                                                      Source(원본) 원본
	            //으로 Destination에는 수정이 되야하므로 const가 안붙고, Source쪽에는 원본이 수정이 되면 안되므로 const가 들어간다.





	wchar_t szString[100] = L"abc";

	wcscat_s(szString, 100, L"def"); //두번째 인수는 이어 붙일려고 하는 원본 공간의 사이즈를 뜻한다.(버퍼의 전체크기) = szString의 배열 크기 입력
	                                 //L"def" -> 문자열은 const가 전제를 깔고 간다고 했기 때문에 원본수정 불가능이므로 오류 x


}

#include <assert.h>

void StrCat(wchar_t* _pDest, unsigned int _iBuffersize, const wchar_t* _pSrc)
{
	//예외처리
	//이어 붙인 문자의 길이가, 목적지 저장 공간을 넘어서려는 경우.

	int iDestlen = GetLength(_pDest);
	int iSrclen = GetLength(_pSrc);

	if (_iBuffersize < iDestlen + iSrclen + 1)  //+1하는 이유는 NUL문자 공간까지 생각. ->원본 문자길이와 이어붙이는 문자의 길이가 버퍼사이즈(목적지 저장 공간)보다 커지면 안됨.
	{
		assert(nullptr);//assert : 발생하면 안되는 특정상황을 if구문으로 특정짓고 그러한 상황이 나왔을 때, assert 경고문을 내보내서 사용자가 인식할 수 있게 해주는 매크로.
		                //즉 이 함수에서 if구문에 해당하는 특정상황이 생기면 경고처리를 해서 프로그램을 중단시키겠다는 뜻.
	}
	
	//문자열 이어 붙이기
	// 해야할일 체크리스트
	//1.목적지 문자열의 끝을 확인(문자열이 이어 붙을 시작 위치)
	iDestlen; //Dest 문자열의 끝 인덱스 --> 배열[10] =L"abc" 에서 NUL이 들어가는 배열의 위치는 [3]이다. 왜냐하면 배열의 인덱스는 0부터니까. 따라서 문자의 길이(3)가 곳 문자열의 끝 인덱스[3].

	//2.반복적으로 Src 문자열을 Dest끝 위치에 복사하기
	// --> 반복문의 반복 횟수는 원본(소스) 문자의 길이이다. 따라서 for문으로 하는게 적합.
	for (int i = 0; i < iSrclen + 1; ++i)  //i < iSrclen +1 인 이유는 원본(소스) 문자에서의 NUL까지 목적지에 대입해주기 위함.
	{
		_pDest[iDestlen + i] = _pSrc[i];

	}
	
	//3.Src문자열의 끝을 만나면 반복 종료.
	//위 함수에서는 반복횟수에 이미 종료단계까지 설명이 되기 때문에 의미가 없어짐. 그러나 while 함수로 했다면, break로 탈출 조건을 걸어줘야함.

}

int main()
{
	wchar_t szName[10] = L"Raimond";

	int iLen = GetLength(szName);

	wchar_t szString[10] = L"abc";
	StrCat(szString, 10 , L"def");
	
	return 0;
	
}


//wcscmp와 동일한 기능을 하는 함수를 만들어보기.
//wcscmp는 비교대상 2개가 같으면 0, 우선순위가 오른쪽이 더 높으면 1, 왼쪽이면 -1. 우선순위라 함은 abc에서 a가 b나c보다 더 높은 우선순위를 가짐을 의미.

int wcscmp(const wchar_t* _A, const wchar_t* _B)
{
	int i = 0;

	if (_A == _B)  //좌우측 문자열이 같다면 0으로 출력
	{
		return 0;
	}

	while (true)  //좌우측 문자열이 같지 않을 경우 반복문 수행.(각각 문자열의 인덱스를 확인하기 위함.)
	{
		wchar_t a = _A[i];
		wchar_t b = _B[i];

		if (_A[i] < _B[i])    //인덱스 비교해서 우측이 더 크면 -1 출력
		{
			return -1;
		}

		else if (_A[i] > _B[i])     //인덱스 비교해서 좌측이 더 크면 -1 출력
		{
			return 1;
		}


		++i;


	}


}

int main()
{
	int iRet = wcscmp(L"ABCDEFG", L"ABCDEFGHJ");

}


//구조체 포인터

typedef struct _tagMyST     //typedef : 타입디파인, 타입을 재정의한다뜻.
{                           //struct : 구조체
							// C++, C언어 둘 다에서 가능한 사용자 정의 자료형 형식
	int a;
	float f;

}MYST;

int main()
{
	MYST s = {};   //구조체 초기화

	MYST* pST = &s;  // MYST는 8byte 자료형(4 정수/4 실수)
	pST + 1;        //주소를 8byte씩 계산. 

	(*pST).a = 100;           //변수s의 주소값으로 접근한다. -> MYST는 2개의 파트로 나뉘기 때문에 멤버 a의 파트 즉 정수파트로 접근한다. -> 여기에 100을 넣는다.
	(*pST).f = 3.14f;         //변수 s의 주소값으로 접근 후 실수 파트에 3.14f 넣는다.


	pST->a;            // '->'는 역참조한 후 파트를 지칭하는것. s변수 주소로(역참조) 가서 a 파트
	pST->f = 3.14f;    //위쪽 실수파트 식과 같은 뜻.

	return 0;


	

}











//함수의 오버로딩
//함수의 이름은 같지만, 인자의 갯수, 인자의 타입등의 차이로 인해  컴파일러가 구분을 짓기 때문에, 동일한 이름의 함수가 여러개 만들어 질 수 있는 것을 오버로딩이라고 한다.



// 단축키
// 지정한 구문 주석걸기 : ctrl + k, c (컨트롤 케이 누르고 컨트롤 씨눌러야됨)
// 지정한 구문 주석해제 : ctrl + k, u
// 원하는 부분 영역잡기 : Alt Drag 
// 선언(or정의)된 부분으로 이동 : F12
//ctrl + shift + spacec : 함수 선언 보기

// 디버깅 단축키
// 디버깅 시작 : F5
// 다음 중단점까지 코드 실행 : F5
// 중단점 생성 및 해제 : F9
// 디버깅 중, 구문 수행 : F10
// 디버깅 중, 구문 수행(함수 진입) : F11 (더 세부적으로 최소단위 작업으로 구분되어 진행됨)
// 디버깅 중, 디버깅 종료하기 : Shift +F5


//return; , return 0;, return -1;의 의미
//함수 마지막에 나오는 return은 함수에서 도출된 값을 반환한다는 뜻으로 return 0;는 0을 반환한다. 라는 의미지만
//실질적인 의미는 함수식이 성공했다는 의미고 return -1(0이아닌값);은 에러(성공하지못한)함수식이라는 뜻으로 통용되고 있다.
//return;은 아무값도 반환하지 않는다는 뜻으로, 반환값이 없다는 void 함수의 경우 이 함수를 단순 종료시키기 위한 장치로 return;을 사용한다.

//디버그의 순서?
//코드작성 -> 컴파일 단계(파일 단위로 문법 오류 검수) --> 링크 단계(통과된 파일들을 합친다.연결) --> exe 실행파일 생성.