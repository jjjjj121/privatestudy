#include "Arr.h"

#include <iostream>   //이쪽 파일에서는 malloc을 모르기 때문에 참조 필요.
 
// 배열 초기화 함수 식
void InitArr(tArr* _pArr)
{

	_pArr-> pInt = (int*)malloc(sizeof(int) * 2);    //_pArr-> : 역참조시 이쪽 멤버로 접근하라는 뜻으로 주소값을 알아야 하는 상황(포인터)일 때 사용 가능한데, 지금 이 함수는 가변배열의 주소값을 받아
	_pArr-> iCount = 0;                              //활용하고 있기 때문에 사용 가능한 것. 또한 sizeof(int) * 2라고 표현한 이유는 , 8byte로 표기해도 되지만, sizeof는 ()안 데이터 사이즈를 표기하는 것으로
	_pArr-> iMaxcount = 2;                           //int사이즈(4byte) 데이터 * 2 한 값을 malooc : 힙메모리 영역에 생성 한다는 것으로 직관적으로 봤을 때 데이터 사이즈를 보다 더 알기 쉽게 하기 위함. 
	                                                 //참고로 위처럼 sizeof(int)를 했다고해서 동적할당이 int자료형으로만 사용된다는 것은 아니고 그저 int데이터 사이즈값만큼 *2했다는 뜻이므로 서로 관련이 없음. 주의!

}

//재할당 함수 식
//메모리 영역을 할당 받을 때, 그 주소값은 사용자가 원하는 주소값을 받는게 불가능하다.
//따라서 메모리 영역이 꽉차서 더 큰 메모리 영역을 재할당 할 시, 기존에 있던 주소값 뒤이어서 재할당 하는 것이 아니라, 아예 새로운 힙영역에 더 큰 메모리 영역을 재할당 받는 것.
//재할당 함수 식에서 필요한 것
// 1. 재할당 받는 메모리의 크기(기존의 2배,4배 등등)
// 2. 기존 데이터값을 존재해야 하므로, 기존 데이터를 덮어 씌워야한다. --> 새로 생성된 공간의 주소값 필요.
// 3. 기존 생성되었던 힙영역은 해제해줘야함.
// 4. 기존 가변 배열이 가리키는 주소값이 새로운 영역의 주소값으로 변경되야함.
// 5. 변경된 MaxCount 적용(최대값이 2배가 되었으므로)

void Reallocate(tArr* _pArr)
{
	//1. 2배 더 큰 공간을 동적할당한다. and 주소값을 받아놓는다.
	int* pNew = (int*) malloc(_pArr->iMaxcount * 2 * sizeof(int));  //기존의 2배 메모리 영역을 재할당 받을 것임. -> int사이즈만큼 * 최대 인덱스 수 == 기존 메모리 크기 * 2 == (기존의 2배)
	                                                                //malloc으로 재할당 받은 새 공간의 주소값을 새로운 포인터변수로 받아 놓는다 : 기존 데이터값을 입력해줘야하기 때문.

	//2. 기존 공간에 있던 데이터들을 새로 할당한 공간으로 복사시킨다.
	for (int i = 0; i < _pArr->iCount; ++i)
	{
		pNew[i] = _pArr->pInt[i];             // 기존에 있던 i번째 배열의 데이터를 새로할당된 pNew의 i번째 배열에 복사
	}

	//3. 기존 공간 메모리 해제

	free(_pArr->pInt);

	//4. 가변 배열이 가리키는 주소값을 새로 할당된 공간의 주소값으로 변경.

	_pArr->pInt = pNew;

	//5.MaxCount 변경점 적용

	_pArr->iMaxcount *= 2;



}





void PushBack(tArr* _pArr, int _iData)
{

	//힙 영역에 할당한 메모리가 꽉 찬 상태
	if (_pArr->iMaxcount <= _pArr->iCount)       //입력된 데이터 배열을 카운트 한 값이, 메모리 최대값과 같거나, 클 경우  -> 메모리를 추가 할당 해야함.
	{
		//재할당
		Reallocate(_pArr);

	}

	//데이터 추가
	_pArr->pInt[_pArr->iCount++] = _iData;   //객체의 주소값으로 접근 ->iCount가 곧 빈 배열의 인덱스 이므로 [_pArr ->iCount] 인데 데이터 추가 때마다 인덱스가 넘어가기 때문에 ++를 붙여준다.




}



void ReleaseArr(tArr* _pArr)
{
	free(_pArr->pInt);                   //free함수로 주소파트부분을 해제시켜준다.
	_pArr->iCount = 0;                   //해제된 객체이므로 카운트는 0
	_pArr->iMaxcount = 0;                //맥스카운트 또한 0
	
	//텅 빈 공간이 됨.

}



////버블 정렬
//
//void Sort(tArr* _pArr)
//{
//	//예외처리 : 데이터가 1개 이하면 정렬하지 않음. (정렬하기 위해선 2개이상이여야 가능)
//	if (_pArr->iCount <= 1) 
//	{
//		return;
//	}
//
//	int a = 0; //둘의 위치가 바뀌어야 할 때, 데이터를 저장할 객체
//	//반복문 -> 인접한 2개의 인덱스를 비교 후 크기에따라 정렬
//
//	while(true)      //while문은 조건이 true일 경우 계속 반복문을 돌린다는 뜻으로 사실상 탈출조건에 해당하지 않으면 계속 돌리겠다는 의미.
//		             //false일 경우에는 반복문을 끝내겠다는 의미이다.
//	{
//		bool bFinish = true;
//
//		for (int c = 0; c < _pArr->iCount - 1; ++c) // ->여기서 문제는 이 반복문을 끝까지 돌리면 제일 큰 숫자가 오른쪽으로 갔을뿐 나머지 숫자가 정렬되진 않았다. 따라서 이 반복문을 또 반복해야함.
//		{
//
//
//			if (_pArr->pInt[c] > _pArr->pInt[c + 1])//앞이 크다면
//			{
//				a = _pArr->pInt[c];
//				_pArr->pInt[c] = _pArr->pInt[c + 1];
//				_pArr->pInt[c + 1] = a;
//
//				bFinish = false;
//			}
//
//		}
//
//		if (bFinish)    //bFinish가 참일 경우 break를 걸겠다는 탈출 조건으로 for 반복문에서 if구문을 계속 돌았는데 한번도 안걸리고 true가 나왔다는 것은 배열이 정렬된 상태라는 뜻으로
//			break;      //더이상 반복문을 할 의유가 없음을 뜻함. 반대로 false가 되면 참이 아니므로 break조건에 해당하지 않음. 따라서 while 반복문을 다시 시행.
//
//
//	}
//
//
//}
//

//버블 정렬(함수 포인터로 함수를 인자로 사용하기.)
void Sort(tArr* _pArr, void(*SortFunc)(int*, int))
{

	SortFunc(_pArr->pInt, _pArr->iCount); //(데이터의 시작주소 , 데이터가 들어있는 갯수)



}